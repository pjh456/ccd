# 02. 不要把鸡蛋放在同一个篮子里：C 项目工程结构

**本章目标**：

1.  理解多文件开发的重要性，告别“所有代码塞进 `main.c`”的习惯。
2.  掌握标准的 C 语言项目目录结构（`src`, `include`, `build`, `tests`）。
3.  学会编写适应多文件项目结构的 `CMakeLists.txt`。

---

## 为什么代码要“分家”？

当你刚开始学习编程时，一个 `main.c` 文件可能足以承载所有代码。但随着项目复杂度的增加，如果你依然把所有代码写在一个文件里，很快会陷入困境：

1.  **难以维护**：成千上万行的代码堆在一个文件里，寻找、修改特定功能如同大海捞针。
2.  **团队协作障碍**：多人同时修改同一个 `main.c` 文件，会导致频繁的代码冲突和合并噩梦。
3.  **代码复用性差**：你想把某个通用功能（比如动态数组）用到其他项目中？你得从臃肿的 `main.c` 里小心翼翼地“挖”出来。
4.  **编译效率低**：即使只修改了一个小函数，整个庞大的 `main.c` 也必须完全重新编译，耗时更长。

为了解决这些问题，我们需要对项目进行 **模块化** 管理。

---

## C 项目的标准“户型图”

工业界标准的 C/C++ 项目通常遵循以下目录结构。现在，请在你的 `ccd_project` 文件夹中创建这些子目录：

```text
ccd_project/
├── CMakeLists.txt      # 整个项目的“施工图纸”，指导 CMake 如何构建
├── README.md           # 项目的说明书，介绍项目是什么、怎么用
├── .gitignore          # 告诉版本控制工具（如 Git）哪些文件不需要跟踪
├── src/                # [Source] 源文件目录：存放 `.c` 实现文件（“厨房”，具体功能实现）
│   └── main.c          # 程序入口点
├── include/            # [Include] 头文件目录：存放 `.h` 声明文件（“菜单”，功能接口定义）
│   └── (暂时为空，未来会放入公共头文件)
├── build/              # [Build] 构建目录：存放编译过程中产生的所有中间文件和最终可执行文件（“垃圾桶” + “成品”）
└── tests/              # [Tests] 测试目录：存放用于验证代码正确性的测试用例
```

### 职责划分

-   **`src/` (源文件)**：包含所有 `.c` 文件，这些文件定义了函数的具体实现、变量的初始化等。它们是代码的“肉体”。
-   **`include/` (头文件)**：包含所有 `.h` 文件，这些文件包含了函数声明（原型）、结构体定义、宏定义等。它们是代码的“契约”，告诉其他模块“我有什么功能，如何调用”。
-   **`build/` (构建产物)**：由 CMake 和编译器生成，包含 `.o` (目标文件)、`Makefile`、`.exe` (可执行文件) 等。我们通常不手动管理这里的文件。
-   **`tests/` (测试)**：存放对各个模块进行单元测试的代码，确保每个功能都能正常工作。

---

## 动手“搬家”：重构项目结构

现在，让我们把上一章写的 `main.c` 移动到它正确的位置。

1.  **创建 `src/` 文件夹**：如果你还没创建，现在就创建。
2.  **移动 `main.c`**：将根目录下的 `main.c` 文件拖拽或剪切到新创建的 `src/` 文件夹中。
3.  **清理旧的编译产物**：如果根目录下还有 `main.exe` 或 `main` (以及 `build` 文件夹)，请直接删除它们。

现在的项目结构应该是这样的：
```text
ccd_project/
├── CMakeLists.txt
├── src/
│   └── main.c
└── (其他空目录或文件)
```

---

## 升级 `CMakeLists.txt`：适应新结构

文件移动后，之前的 `CMakeLists.txt` 就会“迷路”，因为它不再知道 `main.c` 在哪里。同时，我们需要告诉 CMake，我们的头文件应该去哪里找。

请更新根目录下的 `CMakeLists.txt` 文件，内容如下：

```cmake
# 1. 设定 CMake 的最低版本要求 (建议 3.10 或更高，以获得更多现代特性)
cmake_minimum_required(VERSION 3.10)

# 2. 定义项目名称
project(CCD_Project)

# 3. 设置 C 语言标准为 C11
# C11 支持 // 单行注释、变量可以在代码块任意位置定义等现代特性
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON) # 强制要求 C11 标准

# =========================================================
# 核心配置区域
# =========================================================

# 4. 【关键】告诉编译器：去哪里寻找头文件 (.h)
# `include_directories` 指令添加一个目录到头文件搜索路径
# `${CMAKE_SOURCE_DIR}` 是 CMake 内置变量，代表项目的根目录
# 这样，当你写 #include "my_header.h" 时，编译器就知道要去 include/ 目录里找
include_directories(${CMAKE_SOURCE_DIR}/include)

# 5. 【关键】定义项目的所有源文件 (.c)
# `set(SOURCES ...)` 定义一个名为 `SOURCES` 的变量来存储所有源文件路径
# 手动列出每个源文件路径是最佳实践，确保明确性
set(SOURCES
    src/main.c
    # 未来如果有新的 .c 文件，就在这里添加，例如：
    # src/tokenizer.c
    # src/vector.c
)

# 6. 生成可执行文件
# `add_executable` 指令告诉 CMake 编译这些源文件，生成一个可执行程序
# 第一个参数是生成程序的名称 (例如在 Windows 下会是 ccd_cli.exe)
# 第二个参数是上面定义的 `SOURCES` 变量，包含了所有需要编译的源文件
add_executable(ccd_cli ${SOURCES})

# =========================================================
# 可选但推荐的配置
# =========================================================

# 为所有 target (这里是 ccd_cli) 启用一些常见的编译器警告
# 这有助于编写更健壮、更规范的代码
if(CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
    target_compile_options(ccd_cli PRIVATE
        -Wall          # 开启所有常用警告
        -Wextra        # 开启额外警告
        -Wpedantic     # 严格遵守 C 标准
        -Werror        # 将警告视为错误，强制解决所有警告
    )
endif()
```

#### **为什么手动列出 `SOURCES` 文件？**
当你开始学习时，手动列出文件可以让你对项目中的每一个源文件都有清晰的认识。虽然 `file(GLOB ...)` 可以自动收集文件，但它有一些缺点，例如当新文件添加时 CMake 可能无法自动检测到，需要手动触发。对于初学者，**明确性胜过便利性**。

---

## 再次编译运行：验证新结构

每次你修改了 `CMakeLists.txt`，都需要重新执行 CMake 的配置步骤。

1.  打开你的终端。
2.  **清理 `build` 文件夹** (非常重要，避免旧的配置缓存干扰)：
    -   Windows PowerShell: `Remove-Item -Recurse -Force build && mkdir build`
    -   Windows CMD: `rd /s /q build && mkdir build`
    -   Mac/Linux: `rm -rf build && mkdir build`
3.  进入 `build` 目录：
    ```bash
    cd build
    ```
4.  **生成构建系统** (重新读取 `CMakeLists.txt`)：
    ```bash
    cmake ..
    ```
5.  **编译项目**：
    ```bash
    cmake --build .
    ```
6.  运行程序：
    -   Windows: `.\ccd_cli.exe`
    -   Mac/Linux: `./ccd_cli`

如果屏幕上依然输出了 `Hello, CCD!`，恭喜你！你已经成功地将项目“模块化”，并学会了如何利用 CMake 管理多文件工程。这是一个非常重要的里程碑。

---

## 附加题：配置 `.gitignore` (非常推荐)

如果你打算将代码上传到 GitHub 或 Gitee，`.gitignore` 文件是你的好帮手。它告诉 Git 哪些文件或目录不需要被版本控制，特别是那些编译生成的、临时性的文件。

在项目的根目录（和 `CMakeLists.txt` 同级）下，新建一个名为 `.gitignore` 的文件（注意前面有一个点 `.`），并填入以下内容：

```text
# 忽略 CMake 生成的构建目录
build/

# 忽略 VSCode 配置文件（通常是用户个人偏好，不需共享）
.vscode/

# 忽略操作系统生成的文件
.DS_Store    # macOS
Thumbs.db    # Windows

# 忽略常见的编译产物
*.exe        # Windows 可执行文件
*.o          # 目标文件
*.obj        # 目标文件 (Windows)
*.a          # 静态库 (Linux/Mac)
*.lib        # 静态库 (Windows)
*.dll        # 动态库 (Windows)
*.so         # 动态库 (Linux)
*.dylib      # 动态库 (macOS)
```

这样，当你使用 Git 进行版本控制时，这些文件就不会被意外地提交到仓库中，保持你的仓库干净整洁。

---

## 常见问题 FAQ

**Q: 运行 `cmake ..` 后报错 `Cannot find source file "main.c"`？**
A: 这是最常见的问题！
    1.  **检查路径**：`main.c` 是否真的在 `src/` 文件夹里？
    2.  **检查 `CMakeLists.txt`**：`set(SOURCES src/main.c)` 这行路径是否写对？特别是 `src/` 前缀是否加上了？
    3.  **保存**：确保 `CMakeLists.txt` 文件已经保存。
    4.  **重新运行 `cmake ..`**：CMake 不会自动感知文件的移动，必须重新配置。

**Q: 为什么我要手动列出源文件，而不是让 CMake 自动查找 `src/*.c`？**
A: `file(GLOB ...)` 确实可以让你写 `set(SOURCES src/*.c)` 来自动收集文件。但在大型项目中，这种方式并不被推荐，因为：
    1.  **增量构建问题**：当你在 `src/` 目录下新增一个 `.c` 文件时，CMake 可能不会自动发现它，你需要手动修改 `CMakeLists.txt` (哪怕只是加个空格) 才能触发重新配置。
    2.  **清晰性**：手动列出文件能让你和你的团队更清晰地知道项目由哪些源文件组成。
    在本教程中，为了强调每个文件的作用和手动管理的思维，我们采用手动列出的方式。

---

### 下一章预告

项目骨架搭好了，是时候深入 C 语言的核心了。
下一章 **[03. 结构体与类型定义](03_c_struct_typedef.md)**，我们将回顾 C 语言中最重要的数据类型概念，并为我们的查重器设计第一个关键数据结构——`Token`。