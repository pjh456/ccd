# 08. 教计算机“识字”：词法分析 (Tokenizer) 与状态机

**本章目标**：

1.  **核心痛点**：为什么不能简单地用 `split(' ')` 来切割代码？
2.  **输入输出**：明确 Tokenizer 的工作是将 `char` 流转换为 `Token` 流。
3.  **理论基础**：理解 **有限状态机 (FSM)** 的概念 —— 这是编写 Tokenizer 的万能钥匙。

---

## 1. 人类 vs 计算机：阅读方式的差异

请看这行代码：
```c
int age = 18;
```

**人类（你）** 读这段代码时，一眼就能看出四个部分：

1. `int` (这是一个类型)
2. `age` (这是一个变量名)
3. `=` (这是一个赋值符号)
4. `18` (这是一个数字)

**计算机（程序）** 读这段代码时，它看到的是什么？

它看到的是一个**字符数组**，甚至只是一串 ASCII 码：
```c
['i', 'n', 't', ' ', 'a', 'g', 'e', ' ', '=', ' ', '1', '8', ';', '\0']
```

或者更底层一点：

`105, 110, 116, 32, 97, 103, 101...`

**词法分析器 (Tokenizer / Lexer)** 的工作，就是充当“翻译官”，把这堆毫无意义的字符（Chars），组装成有意义的单词（Tokens）。

---

## 2. 为什么不能用空格切割？

很多初学者会问：“我直接按空格切割字符串不就行了吗？”

对于 `int age = 18;` 来说，好像是可以的。
但是，C 语言（以及大多数编程语言）并不强制要求空格。

请看这段合法的 C 代码：
```c
int a=10+b*(5-c);
```

这里一个空格都没有。如果你按空格切，整个字符串会被当成一个巨大的单词。

但在 Tokenizer 眼里，它必须被切成：

`int`, `a`, `=`, `10`, `+`, `b`, `*`, `(`, `5`, `-`, `c`, `)`。

**结论**：我们要实现的逻辑，必须能够处理 **紧挨着** 的符号和单词。

---

## 3. 核心武器：有限状态机 (FSM)

要解决这个问题，我们需要引入计算机科学中最经典的模型之一：**有限状态机 (Finite State Machine)**。

别被名字吓到了。这就好比你在玩 RPG 游戏，你的角色有几种 **状态**：
- **站立状态**：什么都没做。
- **跑步状态**：按下了方向键。
- **攻击状态**：按下了攻击键。

Tokenizer 也是一样。它在读取字符时，会在不同的状态之间跳来跳去。

### 让我们模拟一下读取 `int a = 10;` 的过程：

#### 初始状态 (Start)

我们在“空闲”状态，准备读取第一个字符。

#### 1. 读到 'i'

- **判断**：这是个字母。
- **动作**：进入 **[标识符/关键字状态]**。
- **继续读**：`n`, `t`... 都是字母，保持在该状态。
- **读到 ' '** (空格)：
    - **判断**：空格不是字母，说明这个单词结束了。
    - **动作**：把刚才攒的 "int" 切下来，打包成一个 Token。
    - **状态**：回到 **[初始状态]**。

#### 2. 读到 'a'

- **判断**：是字母。
- **动作**：进入 **[标识符状态]**。
- **继续读**：`g`, `e`... 保持。
- **读到 ' '**：打包 "age"，回到 **[初始状态]**。

#### 3. 读到 '='

- **判断**：是符号。
- **动作**：进入 **[操作符状态]**。
- **继续读**：下一个是空格。
- **动作**：打包 "="，回到 **[初始状态]**。

#### 4. 读到 '1'
- **判断**：是数字！
- **动作**：进入 **[数字状态]**。
- **继续读**：`8` 是数字，保持。
- **读到 ';'**：
    - **判断**：分号不是数字。
    - **动作**：打包 "18"。
    - **特殊处理**：分号自己也是个符号，直接打包 ";"。
    - **状态**：回到 **[初始状态]**。

### FSM 状态流转图

```text
       [开始 Start]
          │
          │ 读到字母 [a-z]
          ▼
    ┌────────────┐   读到字母/数字    ┌────────────┐
    │ 标识符状态  │ ────────────────► │ 保持标识符 │
    │ Identifier │ ◄──────────────── │   State    │
    └────────────┘   读到符号/空格    └────────────┘
          │ (结束，打包 Token)
          ▼
       [开始 Start]
          │
          │ 读到数字 [0-9]
          ▼
    ┌────────────┐    读到数字        ┌────────────┐
    │  数字状态   │ ────────────────► │  保持数字  │
    │   Number   │ ◄──────────────── │   State    │
    └────────────┘   读到符号/空格    └────────────┘
```

---

## 4. 贪婪匹配 (Greedy Match) 与 前瞻 (Peek)

这里有一个棘手的问题。

假设代码是：
```c
a >= b
```

当 Tokenizer 读到 `>` 时，它应该立刻切分吗？

- 如果立刻切分，得到的是 `>` (大于号)。
- 但下一个字符是 `=`，它们合起来是 `>=` (大于等于号)。

**规则**：Tokenizer 通常是 **贪婪** 的。

它会尽可能多地“吃”字符，直到组不成一个合法的 Token 为止。

这就需要我们之前提到的 **`peek()` (偷看)** 操作：

1. 当前是 `>`。
2. **偷看**下一个字符：是 `=` 吗？
3. 如果是，那就把它也吃进来，变成 `>=`。
4. 如果不是（比如是 `a > b`），那就只切分 `>`。

---

## 5. 总结：我们需要实现什么？

为了把这一章的理论变成下一章的代码，我们需要准备好：

1.  **光标 (Cursor)**：一个指针 `pos`，记录当前读到了第几个字符。
2.  **Peek & Advance**：两个核心函数。
    - `peek()`: 返回当前字符 `src[pos]`。
    - `advance()`: 返回当前字符，并将 `pos++`。
3.  **循环 (Loop)**：一个死循环 `while (peek() != '\0')`，不断地吞吐字符。
4.  **分支 (Switch/If)**：根据 `peek()` 的内容，决定进入哪个处理函数（处理数字？处理字符串？处理符号？）。

---

### 下一章预告

理论课结束，开始写代码！

下一章 **[09. 定义 Token](09_enum_token_type.md)**，我们将扩充之前的 `token.h`，利用枚举（Enum）列出 C 语言中所有的关键字和符号，并完善 Token 的结构体定义，为编写“扫描循环”做好准备。