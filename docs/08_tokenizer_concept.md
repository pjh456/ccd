# 08. 教计算机“识字”：词法分析 (Tokenizer) 与状态机

**本章目标**：

1.  **思维转换**：从“字符串处理”转变为“流式处理”。
2.  **核心痛点**：为什么不能简单地用 `split(' ')` 来切割代码？
3.  **理论基础**：理解 **有限状态机 (FSM)** —— 这是编写 Parser 的万能钥匙。
4.  **架构预览**：预览我们将要实现的 `Tokenizer` 结构体。

---

## 1. 人类 vs 计算机：阅读方式的差异

上一章我们把文件内容读到了内存里。现在，假设内存里有这样一行 C 代码：

```c
int age = 18;
```

**人类（你）** 读这段代码时，一眼就能看出四个部分：
1.  `int` (这是一个类型关键字)
2.  `age` (这是一个变量名)
3.  `=` (这是一个赋值符号)
4.  `18` (这是一个数字)

**计算机（程序）** 读这段代码时，它看到的是什么？
它看到的只是一条 **连绵不绝的字符河流**，甚至是底层的 ASCII 码值：

```text
Stream: [ 'i', 'n', 't', ' ', 'a', 'g', 'e', ' ', '=', ' ', '1', '8', ';', '\0' ]
Index:    0    1    2    3    4    5    6    7    8    9    10   11   12    13
```

**词法分析器 (Tokenizer / Lexer)** 的工作，就是充当“翻译官”。它需要顺着这条河往下走，把这些零散的字符（Chars），组装成有意义的单词（Tokens）。

---

## 2. 为什么不能用空格切割？

很多初学者（习惯了 Python/Java 的高级 API）会问：“我直接按空格 `split` 字符串不就行了吗？”

对于 `int age = 18;` 来说，好像是可以的。
但是，C 语言（以及大多数编程语言）**不强制要求空格**。

请看这段完全合法的 C 代码：

```c
int a=10+b*(5-c);
```

这里一个空格都没有。如果你按空格切，整个字符串会被当成一个巨大的、无法理解的单词。

但在 Tokenizer 眼里，它必须能像手术刀一样，精准地将其切分为：
`int`, `a`, `=`, `10`, `+`, `b`, `*`, `(`, `5`, `-`, `c`, `)`, `;`

**结论**：我们要实现的逻辑，必须能够处理 **紧挨着** 的符号和单词。我们需要一个字符一个字符地扫描。

---

## 3. 核心武器：有限状态机 (FSM)

要解决这个问题，我们需要引入计算机科学中最经典的模型之一：**有限状态机 (Finite State Machine)**。

别被名字吓到了。这就好比你在玩 RPG 游戏，你的角色在同一时间只能处于一种 **状态**：
-   **站立状态**：什么都没做。
-   **跑步状态**：按下了方向键。
-   **攻击状态**：按下了攻击键。

Tokenizer 也是一样。它有一个“光标”（Current Char），当它读到不同的字符时，会在不同的状态之间跳来跳去。

### 模拟读取 `int a = 10;` 的过程：

#### 初始状态 (Start)
我们在“空闲”状态，光标指向 `i`。

#### 1. 读到 'i' (字母)
-   **判断**：这是个字母，说明可能是一个单词的开始。
-   **动作**：切换到 **[标识符状态]**。
-   **继续读**：`n`, `t`... 都是字母，保持在 **[标识符状态]**，把它们拼起来。
-   **读到 ' '** (空格)：
    -   **判断**：空格不是字母，说明单词结束了。
    -   **动作**：把刚才攒的 "int" 切下来，查表发现它是关键字，生成 `T_INT` Token。
    -   **状态**：切回 **[初始状态]**。

#### 2. 读到 'a' (字母)
-   **判断**：又是字母。
-   **动作**：切换到 **[标识符状态]**。
-   **继续读**：`g`, `e`... 拼起来。
-   **读到 ' '**:
    -   **动作**：生成 `T_IDENTIFIER` (内容 "age")。
    -   **状态**：切回 **[初始状态]**。

#### 3. 读到 '=' (符号)
-   **判断**：这是个符号。
-   **动作**：切换到 **[操作符状态]**。
-   **继续读**：下一个是空格。
-   **动作**：生成 `T_ASSIGN` (=)。
-   **状态**：切回 **[初始状态]**。

#### 4. 读到 '1' (数字)
-   **判断**：是数字！
-   **动作**：切换到 **[数字状态]**。
-   **继续读**：`8` 是数字，保持。
-   **读到 ';'**:
    -   **判断**：分号不是数字。
    -   **动作**：生成 `T_NUMBER` (内容 "18")。
    -   **特殊处理**：分号自己也是个符号，直接生成 `T_SEMICOLON` ( ; )。
    -   **状态**：切回 **[初始状态]**。

### 状态流转图

```text
       [开始 Start] <──────────────────────────┐
          │                                    │
          │ 读到字母 [a-z]                      │ 遇到非字母
          ▼                                    │ (空格/符号)
    ┌────────────┐   读到字母/数字    ┌────────────┐
    │ 标识符状态  │ ────────────────► │ 保持标识符 │
    │ Identifier │ ◄──────────────── │   State    │
    └────────────┘                   └────────────┘
          
          │ 读到数字 [0-9]
          ▼
    ┌────────────┐    读到数字        ┌────────────┐
    │  数字状态   │ ────────────────► │  保持数字  │
    │   Number   │ ◄──────────────── │   State    │
    └────────────┘                   └────────────┘
```

---

## 4. 贪婪匹配 (Greedy Match) 与 前瞻 (Peek)

这里有一个棘手的问题。
假设代码是：`if (a >= b)`。

当 Tokenizer 读到 `>` 时，它应该立刻切分吗？

-   如果立刻切分，得到的是 `>` (大于号)。
-   但下一个字符是 `=`，它们合起来是 `>=` (大于等于号)。

**规则**：Tokenizer 通常是 **贪婪** 的。它会尽可能多地“吃”字符，直到组不成一个合法的 Token 为止。

这就需要两个核心操作：
1.  **`peek()` (偷看)**：只看一眼下一个字符是什么，但不移动光标。
2.  **`advance()` (前进)**：吃掉当前字符，光标向后移一位。

**处理 `>=` 的逻辑**：
1.  读到了 `>`。
2.  `peek()` 一下后面是谁？是 `=` 吗？
3.  **Yes**: 那就把 `=` 也吃进来 (`advance`)，生成 `T_GREATER_EQUAL`。
4.  **No**: (比如后面是 `a > b`)，那就只生成 `T_GREATER`。

---

## 5. 架构预览：Tokenizer 结构体

为了实现上述逻辑，我们需要在代码中维护一些状态。
除了之前定义的 `Token` 结构体，我们需要一个新的结构体 `Tokenizer` 来管理整个扫描过程。

它大概长这样（下一章我们会具体定义）：

```c
typedef struct {
    char *source;    // 源代码字符串 (输入流)
    int cursor;      // 当前读到哪里了 (光标)
    int line;        // 当前在第几行 (用来报错：Line 10 error)
    int col;         // 当前在第几列
} Tokenizer;
```

---

## 6. 总结：我们需要实现什么？

为了把这一章的理论变成代码，我们需要在接下来的章节中实现一个 **大循环**：

```c
// 伪代码
while (cursor < length) {
    char c = peek();
    
    if (is_space(c)) { skip(); }
    else if (is_alpha(c)) { scan_identifier(); }
    else if (is_digit(c)) { scan_number(); }
    else { scan_operator(); }
}
```

这种 **“主循环 + 分发函数”** 的模式，就是有限状态机在 C 语言中最简单的实现方式。

---

### 下一章预告

理论课结束，准备动手。

我们之前虽然定义了 `Token`，但还不够完善。下一章 **[09. 定义 Token 类型](09_enum_token_type.md)**，我们将扩充 `token.h`，利用枚举（Enum）列出 C 语言中所有的关键字 (`int`, `return`, `if`...) 和符号，并正式定义 `Tokenizer` 结构体。