# 04. 驯服内存巨兽：栈、堆与动态内存管理

**本章目标**：

1.  **痛点直击**：为什么 `int arr[100];` 在工程中往往是不合格的写法？
2.  **概念建立**：彻底理解 **栈 (Stack)** 和 **堆 (Heap)** 的天壤之别。
3.  **核心技能**：熟练掌握“四大金刚” —— `malloc`、`free`、`calloc`、`realloc`。
4.  **避坑指南**：如何规避 C 语言新手的三大死法（段错误、内存泄漏、野指针）。

---

## 1. 数组的尴尬：为什么我们需要动态内存？

在学校的 C 语言课本里，我们通常这样定义数组：

```c
// 定义一个能存 100 个整数的数组
int scores[100];
```

这在算法题里够用了，但在像 CCD 这样的实际工程中，它有一个致命伤：**死板**。

-   **场景 A (浪费)**：你只想读 5 个数，结果你申请了 100 个位置，浪费了 95 个。
-   **场景 B (溢出)**：你需要读入一个 10 万行的源代码文件。结果数组只有 100，程序直接崩溃。

你可能会说：“那我定义 `int scores[1000000];` 不就行了？”
**绝对不行！** 这种数组是存放在**栈 (Stack)** 上的。栈的空间非常宝贵且有限（通常只有几 MB）。如果你敢在函数里写 `int arr[1000000];`，程序运行瞬间就会因为 **Stack Overflow (栈溢出)** 而暴毙。

我们需要一种机制，能够 **“按需索取，用完即还”**，而且空间巨大。这就是 **堆 (Heap)**。

---

## 2. 内存的双城记：栈 vs 堆

我们可以把内存想象成两家旅馆：

### 栈 (Stack)：快捷胶囊旅馆
-   **特点**：自动管理，速度极快，但房间很小，且数量有限。
-   **谁住这里**：局部变量 (`int i`, `Token t`)、函数参数。
-   **生命周期**：**函数结束，立刻自动退房**。数据瞬间消失，不留痕迹。

### 堆 (Heap)：超大仓储中心
-   **特点**：手动管理，空间巨大（取决于你的内存条），速度稍慢。
-   **谁住这里**：通过 `malloc` 申请的数据。
-   **生命周期**：**永不自动退房**。只要你不主动调用 `free`，它就一直占着地方，直到程序结束。

---

## 3. 内存管理的“四大金刚”

要操作堆内存，我们需要引入标准库：`#include <stdlib.h>`。

### 1. `malloc` (Memory Allocate) —— 给我一块地
```c
// 申请能放 10 个 int 的空间
// sizeof(int) 通常是 4 字节，所以这里申请了 40 字节
int *arr = (int*)malloc(10 * sizeof(int));

// 【必做检查】：如果内存耗尽（比如你申请了 100GB），malloc 会返回 NULL
if (arr == NULL) {
    // 处理错误，通常是报错退出
    exit(1);
}
```

### 2. `free` —— 退房走人
C 语言没有 Java/Python 那样的垃圾回收 (GC)。
如果你申请了内存却不释放，这就叫 **内存泄漏 (Memory Leak)**。久而久之，你的程序会吃光电脑内存。

```c
free(arr);  // 归还内存给操作系统
arr = NULL; // 【好习惯】：释放后立即将指针置空，防止变成“野指针”
```

### 3. `calloc` (Clean Allocate) —— 拎包入住
`malloc` 申请到的内存里是脏的（可能残留着上一个程序的数据）。
`calloc` 会多做一步：**把内存全部清零**。

```c
// 申请 10 个 int，并全部初始化为 0
// 参数：(数量, 单个元素大小)
int *arr = (int*)calloc(10, sizeof(int));
```

### 4. `realloc` (Re-Allocate) —— 扩建魔法
这是最神奇的一个函数，也是我们在下一章写动态数组 (`Vector`) 的核心。
**场景**：你申请了 10 个空间，结果发现不够用了，想要 20 个。

```c
// 尝试把 arr 的空间扩大到 20 个 int
// 关键点：原来的数据（前 10 个）会被保留！
int *new_arr = (int*)realloc(arr, 20 * sizeof(int));

if (new_arr != NULL) {
    arr = new_arr; // 更新指针，因为数据可能搬家了
} else {
    // 扩容失败（极少见），原内存 arr 依然有效，需要决定怎么处理
}
```

---

## 4. 常见的“三种死法”

新手写 C 语言，90% 的崩溃都源于以下三个错误：

### 死法一：段错误 (Segmentation Fault)
试图访问不属于你的内存地址。
```c
int *p = NULL;
*p = 10; // 崩溃！不能往空地址写数据。

free(arr);
arr[0] = 5; // 崩溃！试图访问已经退房的内存 (Use After Free)。
```

### 死法二：内存泄漏 (Memory Leak)
光借不还。虽然程序不会立刻崩，但运行久了会卡死系统。
```c
void loop() {
    while(1) {
        // 每次循环申请 1KB，但不释放
        void *p = malloc(1024); 
    }
}
```

### 死法三：野指针 (Wild Pointer)
指针指向了一块随机的垃圾地址。
```c
int *p;     // 没初始化，p 的值是随机的垃圾值
*p = 100;   // 运气好：崩溃；运气不好：修改了重要数据，产生诡异 BUG。
```

---

## 5. 实战演练：手动实现扩容逻辑

让我们在 `src` 目录下新建一个临时文件 `memory_demo.c`，体验一下动态扩容的过程。
（注意：这个文件只是为了演示，不属于项目的一部分，测试完可以删掉）。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int capacity = 2; // 初始容量只有 2
    int count = 0;    // 当前存了几个数
    
    // 1. 初始申请
    int *numbers = (int*)malloc(capacity * sizeof(int));
    if (!numbers) return 1;

    printf("请输入整数 (输入 -1 结束):\n");

    while (1) {
        int input;
        scanf("%d", &input);
        if (input == -1) break;

        // 2. 如果满了，触发扩容机制
        if (count == capacity) {
            capacity *= 2; // 容量翻倍
            printf(">> 容量不足，扩容至: %d\n", capacity);
            
            // 重新分配内存
            // 注意：realloc 会自动把旧数据拷贝到新地方
            int *new_area = (int*)realloc(numbers, capacity * sizeof(int));
            if (!new_area) {
                printf("内存耗尽！\n");
                free(numbers);
                return 1;
            }
            numbers = new_area; // 更新指针
        }

        numbers[count] = input;
        count++;
    }

    // 3. 打印结果
    printf("你输入了: ");
    for (int i = 0; i < count; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    // 4. 清理现场 (必须！)
    free(numbers);
    
    return 0;
}
```

### 编译运行
由于这是个临时文件，我们直接用 GCC 编译即可，不用改 `CMakeLists.txt`。
在终端输入：
```bash
gcc src/memory_demo.c -o demo
./demo
```

### 预期体验
当你输入第 3 个数字时，你会看到控制台输出 `>> 容量不足，扩容至: 4`。
当你输入第 5 个数字时，会输出 `>> 容量不足，扩容至: 8`。

这就是 C++ `std::vector` 或 Java `ArrayList` 底层的真实运作原理！

---

## 6. 进阶铺垫：`void*` 通用指针

在下一章中，我们要写一个通用的容器。
- 如果我们写 `int*`，它只能存整数。
- 如果我们写 `Token*`，它只能存 Token。

C 语言提供了一个神器：**`void*`**。
-   它可以指向 **任何类型** 的数据地址。
-   `void*` 就像是一个没有标签的快递盒。你知道里面有东西，但不知道是什么。
-   使用时，需要把它 **强制转换** 回原本的类型（比如 `(Token*)ptr`）。

---

### 下一章预告

掌握了 `malloc`、`realloc` 和 `void*`，你就集齐了打造神兵利器的所有材料。

下一章 **[05. 动态数组：设计思路](05_vector_theory.md)**，我们将不再手写扩容逻辑，而是将其封装成一个通用的 **动态数组库 (Vector)**。它是整个查重器项目的基石，用来存储我们即将解析的成千上万个 Token。