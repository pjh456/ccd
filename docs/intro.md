# C Clone Detector 实战教程

欢迎来到 CCD 开发实战。

本教程专为 **刚学完 C 语言基础**（会写循环、基本指针、结构体）的同学设计。

我们将通过实现一个代码查重器，带你从“会写代码”进阶到“会做工程”。

> **核心思路**：我们不是在写编译器，我们是在写一个“代码特征提取器”。我们的目标是把易变的代码（文本），转化为不变的特征（数学指纹）。

---

> **注意**
> 本教程基于 AI 生成，由人工进行校对检查，
> 部分代码实现可能与最终实现有所不同，
> 需要注意甄别。
> 如读者发现了代码实现或专业词汇上的问题，欢迎提出 issue 或 PR。

---

## 课程目录导航

我们将整个开发过程拆解为 **8 个模块**。请务必按顺序修炼，切勿跳关。

### 第一模块：环境与 C 语言核心“补课”

> **目标**：在开始写第一行代码前，扫清 C 语言语法的最大障碍，建立工程化思维。

- **[01. 环境搭建与工具链](01_setup_env.md)**
    - 抛弃 Dev-C++：安装 VSCode + GCC + CMake。
    - 什么是命令行？如何在终端像黑客一样编译程序？
- **[02. 工程结构设计](02_project_layout.md)**
    - 代码不能全塞在 `main.c` 里。
    - 为什么要有 `include` 和 `src` 文件夹？（头文件 vs 源文件）。
    - `CMakeLists.txt` 入门：项目构建的“说明书”。
- **[03. 结构体与类型定义](03_c_struct_typedef.md)**
    - **基础**：`struct` 内存布局是怎样的？
    - **进阶**：为什么要用 `typedef`？(少写 `struct` 关键字)。
    - **实战**：设计一个 `Token` 结构体来练手。
- **[04. 指针与堆内存管理](04_c_memory_pointers.md)**
    - **痛点**：栈 (Stack) 和 堆 (Heap) 的区别。
    - **核心**：`malloc`、`calloc`、`realloc` 和 `free` 的使用范式。
    - **避坑**：野指针、内存泄漏与段错误 (Segmentation Fault) 的调试技巧。

### 第二模块：造轮子 —— 基础设施建设

> **目标**：C 语言标准库太简陋了，我们需要自己造一些好用的容器和工具。

- **[05. 动态数组：设计思路](05_vector_theory.md)**
    - 为什么数组 `int a[100]` 不够用？
    - 如何设计一个能“自动扩容”的容器？
    - `void*` 泛型指针：如何让一个 Vector 既能存 `int` 又能存 `struct`？
- **[06. 动态数组：代码实现](06_vector_impl.md)**
    - 手把手实现 `vector_new`, `vector_push`, `vector_get`。
    - **难点**：`realloc` 扩容时的内存搬运逻辑。
- **[07. 文件读取与缓冲](07_file_io.md)**
    - 如何把一个 `.c` 文件一次性读入内存？
    - `fopen`, `fseek`, `ftell`, `fread` 组合拳。

### 第三模块：教计算机“识字” (Tokenizer)

> **目标**：将代码字符串切分为有意义的单词，去除“噪音”（空格、换行、注释）。

- **[08. 词法分析原理](08_tokenizer_concept.md)**
    - 人类怎么看代码 vs 计算机怎么看代码。
    - **状态机 (FSM)**：从“读字符”到“读状态”的思维转变。
- **[09. 定义 Token 类型](09_enum_token_type.md)**
    - 使用 `enum` 枚举所有可能的 Token 类型 (关键字、符号、标识符)。
    - 完善 `Token` 结构体。
- **[10. 扫描循环实现](10_tokenizer_loop.md)**
    - “光标”的概念：`peek()` (偷看) 和 `advance()` (前进)。
    - 主循环逻辑：吃掉空格 -> 识别数字 -> 识别字符 -> 报错。
- **[11. 复杂 Token 处理](11_tokenizer_details.md)**
    - 处理字符串字面量 ` "hello world" `。
    - 处理双字符运算符（`+` vs `++` vs `+=`）。
    - 区分关键字 `int` 和变量名 `interval`。

### 第四模块：骨架提取 —— 粗粒度语句分析 (StatementUnit)

> **目标**：在不理解具体语法的情况下，先利用 `{}` 和 `;` 抓出代码的逻辑骨架。这是抗混淆的关键一步。

- **[12. 语句单元设计](12_statement_unit_concept.md)**
    - 为什么需要粗粒度扫描？(StatementUnit vs AST)。
    - 定义 `StatementUnit`：Compound, If, Loop, Declaration 等类型。
- **[13. 递归扫描实战](13_statement_unit_impl.md)**
    - 处理花括号 `{ ... }` 的嵌套逻辑。
    - 利用栈或递归函数构建语句树。
    - 能够区分 `if (...) { ... }` 和 `a = b;` 的结构差异。

### 第五模块：攻克难点 —— 声明解析 (DeclUnit)

> **目标**：C 语言最难的部分是声明（如 `int *(*x)[5]`）。我们需要专门的模块来解析它，以便构建符号表。

- **[14. C 语言声明的奥秘](14_decl_concept.md)**
    - 类型说明符 (Type Specifier) vs 声明符 (Declarator)。
    - 为什么要区分“类型”和“变量”？
- **[15. 声明解析器实现](15_decl_parser.md)**
    - 解析指针 `*`、数组 `[]` 和函数 `()`。
    - **符号表 (Symbol Table)** 初探：记录变量名和作用域，解决 `T * a` 是乘法还是声明的歧义。

### 第六模块：构建全貌 —— 抽象语法树 (AST)

> **目标**：将“语句骨架”和“详细声明”结合，生成完整的树形结构。

- **[16. 抽象语法树设计](16_ast_design.md)**
    - 什么是 AST？父节点与子节点的关系。
    - **高级 C 语法**：`union` (联合体) 在 AST 节点设计中的妙用。
- **[17. 递归下降解析 (Recursive Descent)](17_parser_impl.md)**
    - 最直观的 Parser 写法。
    - 实战：解析简单的表达式并将节点挂载到树上。
    - 将前面的 StatementUnit 转化为精细的 ASTNode。

### 第七模块：核心算法 —— 特征提取与比对

> **目标**：将语法树转化为数学指纹，计算相似度。

- **[18. 归一化 (Normalization)](18_normalization.md)**
    - 忽略变量名：为什么 `int a = 1` 和 `int b = 1` 是一样的？
    - 遍历 AST 并重写节点内容，统一特征。
- **[19. 特征生成 (N-Grams)](19_ngrams.md)**
    - 什么是 N-Grams (N元语法)？
    - 滑动窗口算法：将 AST 序列转化为特征序列。
- **[20. 指纹与哈希 (MinHash)](20_minhash.md)**
    - 简单的字符串哈希函数 (FNV-1a)。
    - MinHash 原理：如何用固定长度的数组代表无限长的代码？
    - Jaccard 相似度计算。

### 第八模块：工程收尾

> **目标**：将所有模块串联起来，成为一个可用的命令行工具。

- **[21. 命令行接口 (CLI)](21_cli_main.md)**
    - 解析 `main(argc, argv)` 参数。
    - 完整流水线：`File -> Token -> Unit -> Decl -> AST -> Hash -> Report`。
- **[22. 测试与调试](22_tests_debug.md)**
    - 编写简单的测试脚本。
    - 使用 Valgrind 检查内存泄漏（C 语言开发的最后一道关卡）。
- **[23. 总结与展望](23_conclusion.md)**
    - 我们学到了什么？
    - 如何继续优化？(性能优化、支持更多语法)。

---

## 给学习者的建议

1.  **不要跳过第一模块**：如果你对 `malloc` 有哪怕一点点不确定，请仔细阅读第 04 章。内存错误是 C 语言开发中最令人沮丧的 Bug，也是劝退新手的最大原因。
2.  **手敲代码**：文档中会提供核心代码片段，但请务必自己手敲一遍，不要复制粘贴。手敲过程中的拼写错误也是学习的一部分。
3.  **善用 Debug**：在 VSCode 中打断点，看变量在内存里是怎么变的，比看书管用一百倍。
4.  **心态建设**：写 Parser 是很难的，报错是很正常的。遇到 Segmentation Fault 不要慌，这是 C 语言在教你做事。

---

### 下一步？

准备好你的编译器，点击 **[01. 环境搭建与工具链](01_setup_env.md)** 开始第一步！
